From 145a3834dcbb6753a2ae999e5286b34892e4ebb3 Mon Sep 17 00:00:00 2001
From: pseregiet <patryk.seregiet@gmail.com>
Date: Fri, 31 Dec 2021 00:43:31 +0100
Subject: [PATCH 1/4] sg_make_image_with_mipmaps

---
 sokol_gfx.h | 96 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 96 insertions(+)

diff --git a/sokol_gfx.h b/sokol_gfx.h
index 3b48447..cf61442 100644
--- a/sokol_gfx.h
+++ b/sokol_gfx.h
@@ -2427,6 +2427,7 @@ SOKOL_GFX_API_DECL void sg_pop_debug_group(void);
 /* resource creation, destruction and updating */
 SOKOL_GFX_API_DECL sg_buffer sg_make_buffer(const sg_buffer_desc* desc);
 SOKOL_GFX_API_DECL sg_image sg_make_image(const sg_image_desc* desc);
+SOKOL_GFX_API_DECL sg_image sg_make_image_with_mipmaps(const sg_image_desc* desc);
 SOKOL_GFX_API_DECL sg_shader sg_make_shader(const sg_shader_desc* desc);
 SOKOL_GFX_API_DECL sg_pipeline sg_make_pipeline(const sg_pipeline_desc* desc);
 SOKOL_GFX_API_DECL sg_pass sg_make_pass(const sg_pass_desc* desc);
@@ -15494,6 +15495,101 @@ SOKOL_API_IMPL sg_image sg_make_image(const sg_image_desc* desc) {
     return img_id;
 }
 
+SOKOL_API_IMPL sg_image sg_make_image_with_mipmaps(const sg_image_desc* desc_)
+{
+    sg_image_desc desc = *desc_;
+    SOKOL_ASSERT(desc.pixel_format == SG_PIXELFORMAT_RGBA8
+                || desc.pixel_format == SG_PIXELFORMAT_BGRA8
+                || desc.pixel_format == SG_PIXELFORMAT_R8);
+
+    unsigned pixel_size = _sg_pixelformat_bytesize(desc.pixel_format);
+    int w = desc.width;
+    int h = desc.height * desc.num_slices;
+    int total_size = 0;
+    for (int level = 1; level < SG_MAX_MIPMAPS; ++level) {
+        w /=2;
+        h /=2;
+
+        if (w < 1 && h < 1)
+            break;
+
+        total_size += (w * h * pixel_size);
+    }
+
+    int cube_faces = 0;
+    for (; cube_faces < SG_CUBEFACE_NUM; ++cube_faces) {
+        if (!desc.data.subimage[cube_faces][0].ptr)
+            break;
+    }
+
+    total_size *= (cube_faces+1);
+    unsigned char *big_target = SOKOL_MALLOC(total_size);
+    unsigned char *target = big_target;
+
+    for (int cube_face = 0; cube_face < cube_faces; ++cube_face)
+    {
+        int target_width = desc.width;
+        int target_height = desc.height;
+        int dst_height = target_height * desc.num_slices;
+
+        for (int level = 1; level < SG_MAX_MIPMAPS; ++level) {
+            unsigned char* source = (unsigned char*)desc.data.subimage[cube_face][level - 1].ptr;
+            if (!source)
+                break;
+
+            int source_width = target_width;
+            int source_height = target_height;
+            target_width /= 2;
+            target_height /= 2;
+            if (target_width < 1 && target_height < 1)
+                break;
+
+            if (target_width < 1)
+                target_width = 1;
+
+            if (target_height < 1)
+                target_height = 1;
+
+            dst_height /= 2;
+            unsigned img_size = target_width * dst_height * pixel_size;
+            unsigned char *miptarget = target;
+
+            for (int slice = 0; slice < desc.num_slices; ++slice) {
+                for (int x = 0; x < target_width; ++x)
+                {
+                    for (int y = 0; y < target_height; ++y)
+                    {
+                        for (int chanell = 0; chanell < pixel_size; ++chanell)
+                        {
+                            int color = 0;
+                            int sx = x * 2;
+                            int sy = y * 2;
+                            color += source[source_width * pixel_size * sx + sy * pixel_size + chanell];
+                            color += source[source_width * pixel_size * (sx + 1) + sy * pixel_size + chanell];
+                            color += source[source_width * pixel_size * (sx + 1) + (sy + 1) * pixel_size + chanell];
+                            color += source[source_width * pixel_size * sx + (sy + 1) * pixel_size + chanell];
+                            color /= 4;
+                            miptarget[target_width * pixel_size * (x) + (y) * pixel_size + chanell] = (uint8_t)color;
+                        }
+                    }
+                }
+
+                source += (source_width * source_height * pixel_size);
+                miptarget += (target_width * target_height * pixel_size);
+            }
+            desc.data.subimage[cube_face][level].ptr = target;
+            desc.data.subimage[cube_face][level].size = img_size;
+            target += img_size;
+            if (desc.num_mipmaps <= level)
+                desc.num_mipmaps = level + 1;
+        }
+    }
+
+    sg_image img = sg_make_image(&desc);
+    SOKOL_FREE(big_target);
+    return img;
+}
+
 SOKOL_API_IMPL sg_shader sg_make_shader(const sg_shader_desc* desc) {
     SOKOL_ASSERT(_sg.valid);
     SOKOL_ASSERT(desc);
-- 
2.41.0

